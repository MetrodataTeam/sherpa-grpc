# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sherpa.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class SenseVoiceLanguage(betterproto.Enum):
    auto = 0
    zh = 1
    en = 2
    yue = 3
    ja = 4
    ko = 5
    nospeech = 6


class SenseVoiceTextnorm(betterproto.Enum):
    withitn = 0
    woitn = 1


@dataclass(eq=False, repr=False)
class SenseVoiceConfig(betterproto.Message):
    lang: Optional["SenseVoiceLanguage"] = betterproto.enum_field(1, optional=True)
    textnorm: Optional["SenseVoiceTextnorm"] = betterproto.enum_field(2, optional=True)


@dataclass(eq=False, repr=False)
class DiarizationConfig(betterproto.Message):
    clustering_num_clusters: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_INT32
    )
    clustering_threshold: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_FLOAT
    )
    recognize: Optional[bool] = betterproto.bool_field(3, optional=True)


@dataclass(eq=False, repr=False)
class PunctuationConfig(betterproto.Message):
    enable: Optional[bool] = betterproto.bool_field(1, optional=True)


@dataclass(eq=False, repr=False)
class Audio(betterproto.Message):
    info: Optional[str] = betterproto.string_field(2, optional=True)
    """for debug/logging usage"""

    data: bytes = betterproto.bytes_field(1)
    is_numpy_data: Optional[bool] = betterproto.bool_field(7, optional=True)
    """whether the data is numpy array"""

    sense_voice: Optional["SenseVoiceConfig"] = betterproto.message_field(
        3, optional=True
    )
    diarization: Optional["DiarizationConfig"] = betterproto.message_field(
        4, optional=True
    )
    punctuation: Optional["PunctuationConfig"] = betterproto.message_field(
        5, optional=True
    )


@dataclass(eq=False, repr=False)
class OfflineRecognitionResult(betterproto.Message):
    lang: str = betterproto.string_field(1)
    emotion: str = betterproto.string_field(2)
    event: str = betterproto.string_field(3)
    text: str = betterproto.string_field(4)
    timestamps: List[float] = betterproto.float_field(5)
    tokens: List[str] = betterproto.string_field(6)
    words: List[str] = betterproto.string_field(7)


@dataclass(eq=False, repr=False)
class OfflineSpeakerDiarizationSegment(betterproto.Message):
    speaker: int = betterproto.uint32_field(1)
    start: float = betterproto.float_field(2)
    end: float = betterproto.float_field(3)
    text: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class OfflineSpeakerDiarizationResult(betterproto.Message):
    segments: List["OfflineSpeakerDiarizationSegment"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class OfflineSpeakerIdentificationResult(betterproto.Message):
    embedding: List[float] = betterproto.float_field(1)


class SherpaServiceStub(betterproto.ServiceStub):
    async def vad(
        self,
        audio: "Audio",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OfflineSpeakerDiarizationResult":
        return await self._unary_unary(
            "/sherpa.SherpaService/vad",
            audio,
            OfflineSpeakerDiarizationResult,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def offline_recognize(
        self,
        audio: "Audio",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OfflineRecognitionResult":
        return await self._unary_unary(
            "/sherpa.SherpaService/offline_recognize",
            audio,
            OfflineRecognitionResult,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def offline_speaker_diarization(
        self,
        audio: "Audio",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OfflineSpeakerDiarizationResult":
        return await self._unary_unary(
            "/sherpa.SherpaService/offline_speaker_diarization",
            audio,
            OfflineSpeakerDiarizationResult,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def offline_speaker_identification(
        self,
        audio: "Audio",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OfflineSpeakerIdentificationResult":
        return await self._unary_unary(
            "/sherpa.SherpaService/offline_speaker_identification",
            audio,
            OfflineSpeakerIdentificationResult,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class SherpaServiceBase(ServiceBase):

    async def vad(self, audio: "Audio") -> "OfflineSpeakerDiarizationResult":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def offline_recognize(self, audio: "Audio") -> "OfflineRecognitionResult":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def offline_speaker_diarization(
        self, audio: "Audio"
    ) -> "OfflineSpeakerDiarizationResult":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def offline_speaker_identification(
        self, audio: "Audio"
    ) -> "OfflineSpeakerIdentificationResult":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_vad(
        self, stream: "grpclib.server.Stream[Audio, OfflineSpeakerDiarizationResult]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.vad(request)
        await stream.send_message(response)

    async def __rpc_offline_recognize(
        self, stream: "grpclib.server.Stream[Audio, OfflineRecognitionResult]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.offline_recognize(request)
        await stream.send_message(response)

    async def __rpc_offline_speaker_diarization(
        self, stream: "grpclib.server.Stream[Audio, OfflineSpeakerDiarizationResult]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.offline_speaker_diarization(request)
        await stream.send_message(response)

    async def __rpc_offline_speaker_identification(
        self, stream: "grpclib.server.Stream[Audio, OfflineSpeakerIdentificationResult]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.offline_speaker_identification(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/sherpa.SherpaService/vad": grpclib.const.Handler(
                self.__rpc_vad,
                grpclib.const.Cardinality.UNARY_UNARY,
                Audio,
                OfflineSpeakerDiarizationResult,
            ),
            "/sherpa.SherpaService/offline_recognize": grpclib.const.Handler(
                self.__rpc_offline_recognize,
                grpclib.const.Cardinality.UNARY_UNARY,
                Audio,
                OfflineRecognitionResult,
            ),
            "/sherpa.SherpaService/offline_speaker_diarization": grpclib.const.Handler(
                self.__rpc_offline_speaker_diarization,
                grpclib.const.Cardinality.UNARY_UNARY,
                Audio,
                OfflineSpeakerDiarizationResult,
            ),
            "/sherpa.SherpaService/offline_speaker_identification": grpclib.const.Handler(
                self.__rpc_offline_speaker_identification,
                grpclib.const.Cardinality.UNARY_UNARY,
                Audio,
                OfflineSpeakerIdentificationResult,
            ),
        }
